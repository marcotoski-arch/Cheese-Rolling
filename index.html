<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cheese Rolling ‚Äî Anna & Marco</title>
  <style>
    :root{--panel:rgba(15,20,35,.78);--accent:#ffcc00;--text:#eaf0ff;}
    html,body{height:100%;margin:0;background:#081024;color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;overflow:hidden}
    #wrap{position:relative;height:100%;}
    canvas{position:absolute;inset:0;}

    .hud{position:absolute;left:12px;top:12px;display:flex;gap:14px;align-items:center;
      background:rgba(0,0,0,.28);backdrop-filter:blur(6px);padding:10px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.12);flex-wrap:wrap}
    .hud b{font-variant-numeric:tabular-nums;}
    .badge{display:inline-flex;gap:8px;align-items:center}
    .dot{width:10px;height:10px;border-radius:99px;background:var(--accent);box-shadow:0 0 14px rgba(255,204,0,.7)}

    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;}
    .panel{width:min(760px,94vw);background:var(--panel);border:1px solid rgba(255,255,255,.14);
      border-radius:18px;box-shadow:0 18px 60px rgba(0,0,0,.55);padding:18px 18px 16px;}
    .panel h1{margin:0 0 12px;font-size:22px;letter-spacing:.2px;text-align:center}
    .row{display:flex;gap:12px;flex-wrap:wrap;justify-content:center}
    button{cursor:pointer;border:0;border-radius:14px;padding:11px 14px;font-weight:650;
      background:rgba(255,255,255,.10);color:var(--text);border:1px solid rgba(255,255,255,.16)}
    button:hover{background:rgba(255,255,255,.16)}
    .primary{background:rgba(255,204,0,.16);border-color:rgba(255,204,0,.45)}
    .primary:hover{background:rgba(255,204,0,.22)}
    .choice{flex:1;min-width:240px;display:flex;gap:10px;align-items:center;justify-content:space-between}
    .chip{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border-radius:999px;
      background:rgba(0,0,0,.18);border:1px solid rgba(255,255,255,.12);font-size:12px;color:rgba(234,240,255,.85)}
    .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;background:rgba(0,0,0,.30);padding:2px 6px;border-radius:8px;border:1px solid rgba(255,255,255,.14)}
    .hidden{display:none}
    input{
      width:min(520px,86vw);
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.25);
      color:var(--text);
      outline:none;
      font-size:14px;
    }
    input::placeholder{color:rgba(234,240,255,.55)}
    .lb{
      width:min(520px,86vw);
      margin:12px auto 0;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.18);
      text-align:left;
    }
    .lb h3{margin:0 0 8px;font-size:14px;opacity:.9}
    .lb ol{margin:0;padding-left:18px}
    .lb li{margin:3px 0;opacity:.9}
    #castArt svg{width:min(360px,70vw);height:auto;display:block;margin:10px auto 2px;}
    #castHint{opacity:.85;text-align:center;margin-top:6px}
    .small{opacity:.8;font-size:12px;text-align:center;margin-top:8px}
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>

  <div class="hud" id="hud" style="display:none">
    <span class="badge"><span class="dot"></span><span><b id="meters">0</b> m</span></span>
    <span class="badge">üíç <b id="rings">0</b></span>
    <span class="chip" id="nameChip">Giocatore: ‚Äî</span>
    <span class="chip" id="charChip">Personaggio: ‚Äî</span>
    <span class="chip" id="envChip">Ambiente: ‚Äî</span>
    <span class="chip" id="hintChip">Tap/Spazio salta ¬∑ ‚Üì/Swipe gi√π accovacciati</span>
  </div>

  <div class="overlay" id="menu">
    <div class="panel">
      <h1>Cheese Rolling - Anna &amp; Marco</h1>

      <div class="row" style="margin-bottom:10px">
        <input id="playerNameInput" maxlength="18" placeholder="Inserisci nome giocatore (es. Marco)" />
      </div>

      <div class="row" style="margin-bottom:12px">
        <button class="choice primary" id="pickAnna"><span>Anna</span><span class="chip">maglia viola</span></button>
        <button class="choice" id="pickMarco"><span>Marco</span><span class="chip">maglia blu</span></button>
      </div>

      <div class="row">
        <button id="start" class="primary">Inizia</button>
        <button id="how">Come si gioca</button>
      </div>

      <div id="howBox" class="hidden" style="margin-top:12px;text-align:center;color:rgba(234,240,255,.86)">
        <div style="margin-bottom:6px"><b>Obiettivo:</b> fai pi√π metri possibile e raccogli pi√π üíç possibile.</div>
        <div>
          <b>Montagna:</b> salta i cespugli ¬∑ <b>Citt√†:</b> salta le auto ¬∑
          <span class="kbd">Spazio</span>/<span class="kbd">‚Üë</span> salta ¬∑
          <span class="kbd">‚Üì</span> o <b>Swipe gi√π</b> accovacciati.
        </div>
        <div style="margin-top:6px;opacity:.85">
          Consigli: coyote time + jump buffer (salti pi√π reattivi).
        </div>
      </div>

      <div class="lb">
        <h3>üèÜ Classifica (migliori punteggi su questo dispositivo)</h3>
        <ol id="lbMenu"></ol>
      </div>

      <div class="small">Mobile: tap = salto ¬∑ swipe gi√π / tieni premuto = accovacciati</div>
    </div>
  </div>

  <div class="overlay hidden" id="gameover">
    <div class="panel">
      <h1 style="margin:0 0 10px">üí• Game Over</h1>
      <div id="castArt"></div>
      <div id="castHint">ü§ï <b id="finalName">‚Äî</b> ¬∑ <b id="finalMeters">0</b> m ¬∑ üíç <b id="finalRings">0</b></div>

      <div class="lb">
        <h3>üèÜ Classifica</h3>
        <ol id="lbOver"></ol>
      </div>

      <div class="row" style="margin-top:12px">
        <button class="primary" id="retry">Riprova</button>
        <button id="back">Torna al menu</button>
      </div>
      <div class="small">Suggerimento: usa ‚Üì/swipe gi√π nei momenti stretti üòâ</div>
    </div>
  </div>
</div>

<script>
(() => {
  "use strict";

  /* =========================================================
     FOTO REALI (file nella ROOT)
     ========================================================= */
  const faceAnna = new Image();
  faceAnna.src = 'Foto%20Anna.jpg';
  const faceMarco = new Image();
  faceMarco.src = 'Foto%20Marco.jpg';
  faceAnna.onerror = () => (faceAnna._bad = true);
  faceMarco.onerror = () => (faceMarco._bad = true);

  /* =========================================================
     CANVAS
     ========================================================= */
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });

  let W=0, H=0, DPR=1;

  let cobblePattern = null;
  function makeCobblePattern(){
    const s = 420;
    const off = document.createElement('canvas');
    off.width = s; off.height = s;
    const g = off.getContext('2d');

    const base = g.createLinearGradient(0,0,0,s);
    base.addColorStop(0,'#7b8086');
    base.addColorStop(0.65,'#535a63');
    base.addColorStop(1,'#2e343c');
    g.fillStyle = base;
    g.fillRect(0,0,s,s);

    g.globalAlpha = 0.22;
    g.strokeStyle = 'rgba(255,255,255,0.18)';
    g.lineWidth = 1;

    const rows = 14;
    const cols = 12;
    for(let r=0;r<rows;r++){
      const yy = 120 + r*18;
      const wob = Math.sin(r*0.9)*6;
      for(let c=0;c<cols;c++){
        const xx = c*(s/cols) + wob;
        const y = yy + Math.sin((c*0.7)+r)*2;
        g.beginPath();
        g.ellipse(xx, y, 18, 7, 0.08, 0, Math.PI*2);
        g.stroke();
      }
    }
    cobblePattern = ctx.createPattern(off,'repeat');
  }

  function resize(){
    DPR = Math.min(1.5, window.devicePixelRatio || 1);
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);

    canvas.width = Math.floor(W*DPR);
    canvas.height = Math.floor(H*DPR);
    canvas.style.width = W+'px';
    canvas.style.height = H+'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
    makeCobblePattern();
  }
  addEventListener('resize', resize);
  resize();

  /* =========================================================
     UI refs
     ========================================================= */
  const hud = document.getElementById('hud');
  const menu = document.getElementById('menu');
  const over = document.getElementById('gameover');
  const metersEl = document.getElementById('meters');
  const ringsEl = document.getElementById('rings');
  const envChip = document.getElementById('envChip');
  const hintChip = document.getElementById('hintChip');
  const charChip = document.getElementById('charChip');
  const nameChip = document.getElementById('nameChip');

  const finalMetersEl = document.getElementById('finalMeters');
  const finalRingsEl = document.getElementById('finalRings');
  const finalNameEl  = document.getElementById('finalName');
  const castArt = document.getElementById('castArt');

  const lbMenu = document.getElementById('lbMenu');
  const lbOver = document.getElementById('lbOver');

  const nameInput = document.getElementById('playerNameInput');

  const pickAnna = document.getElementById('pickAnna');
  const pickMarco = document.getElementById('pickMarco');
  const startBtn = document.getElementById('start');
  const howBtn = document.getElementById('how');
  const howBox = document.getElementById('howBox');
  const retryBtn = document.getElementById('retry');
  const backBtn = document.getElementById('back');

  /* =========================================================
     LEADERBOARD (localStorage)
     ========================================================= */
  const SCORE_KEY = 'cheeseRolling_scores_v3';

  function loadScores(){
    try { return JSON.parse(localStorage.getItem(SCORE_KEY) || '{}'); }
    catch { return {}; }
  }
  function saveScores(obj){
    localStorage.setItem(SCORE_KEY, JSON.stringify(obj));
  }
  function updateBestScore(player, score){
    const s = loadScores();
    const prev = s[player];
    if(prev === undefined || score > prev){
      s[player] = score;
      saveScores(s);
      return true;
    }
    return false;
  }
  function topList(limit=10){
    const s = loadScores();
    return Object.entries(s)
      .sort((a,b)=>b[1]-a[1])
      .slice(0,limit);
  }
  function renderLB(targetOl){
    targetOl.innerHTML = '';
    const arr = topList(10);
    if(arr.length === 0){
      const li = document.createElement('li');
      li.textContent = 'Nessun punteggio ancora ‚Äî gioca tu il primo!';
      targetOl.appendChild(li);
      return;
    }
    for(const [name,score] of arr){
      const li = document.createElement('li');
      li.textContent = `${name} ‚Äî ${score} m`;
      targetOl.appendChild(li);
    }
  }

  /* =========================================================
     UTILS
     ========================================================= */
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const smooth=(t)=>t*t*(3-2*t);

  function roundRect(x,y,w,h,r){
    const rr=Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  function rectsOverlap(a,b){
    return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y;
  }
  function circleRectOverlap(cx,cy,cr, rx,ry,rw,rh){
    const px=Math.max(rx,Math.min(cx,rx+rw));
    const py=Math.max(ry,Math.min(cy,ry+rh));
    const dx=cx-px, dy=cy-py;
    return dx*dx+dy*dy <= cr*cr;
  }

  /* =========================================================
     WORLD (slope + ground)
     ========================================================= */
  const groundBase=()=>H*0.80;
  const slope=()=>H*0.18/W;
  const groundY=(x)=>groundBase()+slope()*(x-W*0.25);
  const groundAngle=()=>Math.atan(slope());
  const groundLenFactor=()=>Math.hypot(1, slope()); // distanza lungo la pendenza per 1px orizzontale

  function envMode(){ return (Math.floor(distMeters/1000) % 2); }
  function nextEnvMode(){ return ((Math.floor(distMeters/1000)+1) % 2); }

  function previewFactor(){
    const local = distMeters % 1000;
    const start = 840;
    if(local <= start) return 0;
    return smooth(clamp((local-start)/(1000-start),0,1));
  }

  /* =========================================================
     GAME state
     ========================================================= */
  const STATE={MENU:0,RUN:1,OVER:2};
  let state=STATE.MENU;

  let playerName = 'Anonimo';
  let character='Anna';

  function setCharacter(c){
    character=c;
    charChip.textContent='Personaggio: '+c;
    if(c==='Anna'){ pickAnna.classList.add('primary'); pickMarco.classList.remove('primary'); }
    else { pickMarco.classList.add('primary'); pickAnna.classList.remove('primary'); }
  }
  setCharacter('Anna');

  pickAnna.onclick=()=>setCharacter('Anna');
  pickMarco.onclick=()=>setCharacter('Marco');
  howBtn.onclick=()=>howBox.classList.toggle('hidden');

  /* =========================================================
     Physics
     ========================================================= */
  const gravity=2600;
  const jumpV=1060;
  const crouchH = 60;
  const standH  = 84;

  let coyote = 0;
  let jumpBuf = 0;

  const player={
    x:()=>W*0.22,
    y:0, vy:0,
    w:36, h:standH,
    crouch:false, onGround:true,
    runT:0
  };

  const cheese={x:0,y:0,r:20,rot:0}; // r leggermente pi√π grande = pi√π "peso" visivo

  let obstacles=[]; // bush/car
  let rings=[];     // collectibles
  let signs=[];
  let deco=[];      // alberi decorativi (pochi, non ostacoli)

  let speed=468;     // px/s
  let speedAdd=11.0; // accel per 100m
  let distMeters=0;
  let ringsCount=0;

  let nextObsAt=95;   // ostacoli prima
  let nextRingAt=80;
  let nextMilestone=500;

  // pi√π frequenti ostacoli (come richiesto), ma con safety gap
  const MIN_OBS_GAP_PX = 210; // prima 260 -> pi√π ostacoli
  const MIN_RING_GAP_PX = 170;
  const MIN_RING_FROM_OBS_PX = 150;

  // Foot lock
  let bodyOffsetX=0;
  const footLock={active:false, leg:'R', lockScreenX:0, lastTR:0.9, lastTL:0.4, stanceEnd:0.62};

  function resetRun(){
    obstacles=[]; rings=[]; signs=[]; deco=[];
    speed=468; distMeters=0; ringsCount=0;

    nextObsAt=95; nextRingAt=80; nextMilestone=500;

    player.vy=0;
    player.crouch=false;
    player.runT=0;
    player.onGround=true;
    player.h=standH;

    player.y = groundY(player.x()) - player.h;

    cheese.rot=0;
    bodyOffsetX=0;

    footLock.active=false; footLock.leg='R'; footLock.lastTR=0.9; footLock.lastTL=0.4;

    signs.push({x: W*0.65, label: 'Cheese Rolling - Start', kind:'start'});
  }

  function start(){
    const raw = (nameInput.value || '').trim();
    playerName = raw ? raw.slice(0,18) : 'Anonimo';
    nameChip.textContent = 'Giocatore: ' + playerName;

    resetRun();
    hud.style.display='flex';
    menu.classList.add('hidden');
    over.classList.add('hidden');
    state=STATE.RUN;
  }

  startBtn.onclick=start;
  retryBtn.onclick=start;
  backBtn.onclick=()=>{
    state=STATE.MENU;
    hud.style.display='none';
    over.classList.add('hidden');
    menu.classList.remove('hidden');
    renderLB(lbMenu);
  };

  function requestJump(){ jumpBuf = 0.12; }
  function doJump(){
    player.vy = -jumpV;
    player.onGround = false;
    coyote = 0;
    jumpBuf = 0;
  }

  function updateCrouchAndFeetLock(){
    const desiredH = player.crouch ? crouchH : standH;
    if(player.h !== desiredH){
      const footY = player.y + player.h;
      player.h = desiredH;
      player.y = footY - player.h;
    }
  }

  /* =========================================================
     INPUT
     ========================================================= */
  addEventListener('keydown',(e)=>{
    if(['Space','ArrowUp','ArrowDown'].includes(e.code)) e.preventDefault();

    if(state===STATE.RUN){
      if(e.code==='Space'||e.code==='ArrowUp') requestJump();
      if(e.code==='ArrowDown') player.crouch=true;
    }
    if(state===STATE.OVER && (e.code==='Space'||e.code==='Enter')) start();
  },{passive:false});

  addEventListener('keyup',(e)=>{
    if(e.code==='ArrowDown') player.crouch=false;
  },{passive:true});

  // Touch / pointer
  let pointerDown=false, startX=0, startY=0, downTime=0;

  canvas.addEventListener('pointerdown', (e)=>{
    pointerDown=true;
    startX=e.clientX; startY=e.clientY;
    downTime=performance.now();
    if(state===STATE.MENU || state===STATE.OVER){
      start();
      return;
    }
  }, {passive:true});

  canvas.addEventListener('pointermove', (e)=>{
    if(!pointerDown || state!==STATE.RUN) return;
    const dy = e.clientY - startY;
    if(dy > 22) player.crouch = true;
  }, {passive:true});

  canvas.addEventListener('pointerup', (e)=>{
    if(!pointerDown) return;
    pointerDown=false;
    if(state!==STATE.RUN) return;

    const t = performance.now() - downTime;
    const dx = Math.abs(e.clientX - startX);
    const dy = e.clientY - startY;

    if(dy > 22 || t > 220){
      player.crouch = false;
      return;
    }
    if(dx < 10 && Math.abs(dy) < 10){
      requestJump();
    }
  }, {passive:true});

  canvas.addEventListener('pointercancel', ()=>{
    pointerDown=false;
    player.crouch=false;
  }, {passive:true});

  /* =========================================================
     SPAWN
     ========================================================= */
  function lastObstacleX(){
    return obstacles.length ? obstacles[obstacles.length-1].x : -1e9;
  }
  function lastRingX(){
    return rings.length ? rings[rings.length-1].x : -1e9;
  }

  function spawnBush(){
    const h=52+Math.random()*62;
    const w=78+Math.random()*92;
    const x=W+60+Math.random()*160;
    const seed=Math.random()*9999;
    const lumps=4+Math.floor(Math.random()*3);
    obstacles.push({type:'bush', x,w,h, seed, lumps});
  }

  function spawnCar(){
    const w=96+Math.random()*70;
    const h=34+Math.random()*10;
    const x=W+70+Math.random()*190;
    const col=['#d94c4c','#2f7bff','#2f9b72','#6a5b3a','#7a5cff','#3a566b'][Math.floor(Math.random()*6)];
    obstacles.push({type:'car', x,w,h, col});
  }

  function spawnRing(){
    const r=16+Math.random()*4;
    const x=W+60+Math.random()*180;
    const gy=groundY(x);
    const y=gy-(118+Math.random()*175);
    rings.push({x,y,r,spin:Math.random()*Math.PI*2});
  }

  function spawnMilestoneSign(m){
    const x=W+90+Math.random()*140;
    signs.push({x, label:`${m} m`, kind:'mile'});
  }

  // Alberi decorativi (pochi, NON pi√π frequenti come richiesto)
  function spawnTree(){
    const x = W + 80 + Math.random()*620;
    const scale = 0.75 + Math.random()*0.65;
    const depth = 0.65 + Math.random()*0.35;
    const tint = 0.85 + Math.random()*0.20;
    deco.push({type:'tree', x, scale, depth, tint});
  }

  /* =========================================================
     BACKGROUND + GROUND
     ========================================================= */
  function drawSkyDay(){
    const sky = ctx.createLinearGradient(0,0,0,H);
    sky.addColorStop(0,'#0a1a39');
    sky.addColorStop(0.38,'#1b4d8f');
    sky.addColorStop(0.75,'#7bb4ff');
    sky.addColorStop(1,'#bfe1ff');
    ctx.fillStyle=sky;
    ctx.fillRect(0,0,W,H);

    ctx.save();
    ctx.globalAlpha=0.28;
    const sx=W*0.18, sy=H*0.16;
    const sun=ctx.createRadialGradient(sx,sy,0,sx,sy,Math.min(W,H)*0.28);
    sun.addColorStop(0,'rgba(255,255,255,0.85)');
    sun.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle=sun;
    ctx.fillRect(0,0,W,H);
    ctx.restore();
  }

  function drawBackgroundMountain(t){
    drawSkyDay();
    layer(0.44,'#2a3f68',0.00016,16,t);
    layer(0.56,'#1f3154',0.00022,22,t+8000);
    layer(0.66,'#172642',0.00030,28,t+17000);
    function layer(yFrac,color,drift,amp,tt){
      ctx.save();
      ctx.fillStyle=color;
      ctx.beginPath();
      ctx.moveTo(0,H*yFrac);
      for(let x=0;x<=W;x+=88){
        const y = H*yFrac + Math.sin((x*0.008)+(tt*drift))*amp + Math.sin((x*0.017)+(tt*drift*1.35))*amp*0.55;
        ctx.lineTo(x,y);
      }
      ctx.lineTo(W,H); ctx.lineTo(0,H); ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
  }

  function drawLampioni(t){
    const horizon = H*0.52;
    const spacing = 220;
    const drift = (t*0.03) % spacing;

    ctx.save();
    ctx.globalAlpha=0.40;
    ctx.strokeStyle='rgba(30,35,45,0.9)';
    ctx.fillStyle='rgba(30,35,45,0.9)';
    ctx.lineWidth=4;

    for(let i=-1;i<Math.ceil(W/spacing)+2;i++){
      const x = i*spacing - drift;
      const tall = 82 + (i%3)*14;
      const y0 = horizon + 10;
      const y1 = y0 - tall;

      ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y1); ctx.stroke();

      ctx.lineWidth=3;
      ctx.beginPath(); ctx.moveTo(x,y1+10); ctx.lineTo(x+22,y1+18); ctx.stroke();

      ctx.lineWidth=1;
      roundRect(x+16, y1+14, 14, 10, 4);
      ctx.fill();

      ctx.lineWidth=4;
    }

    ctx.globalAlpha=0.20;
    ctx.strokeStyle='rgba(30,35,45,0.75)';
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(0,horizon+16);
    ctx.lineTo(W,horizon+16);
    ctx.stroke();

    ctx.restore();
  }

  function drawBackgroundCity(t){
    drawSkyDay();
    drawLampioni(t);

    ctx.save();
    ctx.globalAlpha=0.08;
    const fog=ctx.createLinearGradient(0,H*0.30,0,H*0.85);
    fog.addColorStop(0,'rgba(255,255,255,0)');
    fog.addColorStop(1,'rgba(255,255,255,0.14)');
    ctx.fillStyle=fog;
    ctx.fillRect(0,0,W,H);
    ctx.restore();
  }

  function drawBackground(mode, t){
    if(mode===0) drawBackgroundMountain(t);
    else drawBackgroundCity(t);
  }

  function drawGroundMountain(){
    const y0=groundY(0), y1=groundY(W);
    ctx.save();
    const g=ctx.createLinearGradient(0,Math.min(y0,y1)-80,0,H);
    g.addColorStop(0,'#6f8862');
    g.addColorStop(0.45,'#4f6246');
    g.addColorStop(1,'#2c332b');
    ctx.fillStyle=g;
    ctx.beginPath();
    ctx.moveTo(0,y0); ctx.lineTo(W,y1); ctx.lineTo(W,H); ctx.lineTo(0,H); ctx.closePath();
    ctx.fill();
    ctx.globalAlpha=0.14;
    ctx.strokeStyle='#1b1f1b';
    for(let i=0;i<18;i++){
      const x=(i/17)*W;
      const y=groundY(x);
      ctx.beginPath();
      ctx.moveTo(x-50,y+18);
      ctx.lineTo(x+80,y+24);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawGroundCity(){
    const y0=groundY(0), y1=groundY(W);
    ctx.save();
    ctx.fillStyle=cobblePattern || '#3a3f49';
    ctx.beginPath();
    ctx.moveTo(0,y0); ctx.lineTo(W,y1); ctx.lineTo(W,H); ctx.lineTo(0,H); ctx.closePath();
    ctx.fill();
    ctx.globalAlpha=0.14;
    const shade=ctx.createLinearGradient(0,Math.min(y0,y1)-40,0,H);
    shade.addColorStop(0,'rgba(0,0,0,0)');
    shade.addColorStop(1,'rgba(0,0,0,0.28)');
    ctx.fillStyle=shade;
    ctx.fillRect(0,0,W,H);
    ctx.restore();
  }

  function drawGround(mode){
    if(mode===0) drawGroundMountain();
    else drawGroundCity();
  }

  function drawUpcomingPreview(){
    const f = previewFactor();
    if(f<=0) { hintChip.textContent = 'Tap/Spazio salta ¬∑ ‚Üì/Swipe gi√π accovacciati'; return; }

    const next = nextEnvMode();
    const stripW = lerp(0, W*0.42, f);
    const x0 = W - stripW;

    const y0 = groundY(x0);
    const y1 = groundY(W);

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(x0,y0);
    ctx.lineTo(W,y1);
    ctx.lineTo(W,H);
    ctx.lineTo(x0,H);
    ctx.closePath();
    ctx.clip();

    if(next===0) drawGroundMountain();
    else drawGroundCity();

    ctx.globalAlpha = 0.35;
    ctx.strokeStyle='rgba(255,255,255,0.55)';
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.moveTo(x0,y0);
    ctx.lineTo(x0,H);
    ctx.stroke();
    ctx.restore();

    hintChip.textContent = (next===0) ? 'Cambio in arrivo: Montagna' : 'Cambio in arrivo: Citt√†';
  }

  /* =========================================================
     DRAW: signs / obstacles / rings / cheese / trees
     ========================================================= */
  function drawSign(s){
    const gy=groundY(s.x);
    const poleH=82;
    const boardW=s.kind==='start' ? 360 : 260;
    const boardH=s.kind==='start' ? 64 : 56;
    const topY=gy-poleH-boardH;

    ctx.save();
    ctx.globalAlpha=0.16;
    ctx.fillStyle='rgba(0,0,0,0.6)';
    ctx.beginPath();
    ctx.ellipse(s.x+18,gy+10,boardW*0.35,10,0.15,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.strokeStyle='rgba(60,45,30,0.95)';
    ctx.lineWidth=6;
    ctx.beginPath();
    ctx.moveTo(s.x,gy);
    ctx.lineTo(s.x,gy-poleH);
    ctx.stroke();

    const wood=ctx.createLinearGradient(0,topY,0,topY+boardH);
    wood.addColorStop(0,'#7a5533');
    wood.addColorStop(1,'#55351f');

    ctx.fillStyle=wood;
    ctx.strokeStyle='rgba(0,0,0,0.35)';
    ctx.lineWidth=2;
    roundRect(s.x-boardW/2,topY,boardW,boardH,12);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle='rgba(255,255,255,0.95)';
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.font='900 22px system-ui';
    ctx.fillText(s.label,s.x,topY+boardH/2);

    if(s.kind==='start'){
      ctx.globalAlpha=0.85;
      ctx.font='800 14px system-ui';
      ctx.fillText('RUN!',s.x,topY+boardH-14);
    }
    ctx.restore();
  }

  function drawBush(o){
    const baseY=groundY(o.x);
    ctx.save();
    ctx.globalAlpha=0.25;
    ctx.fillStyle='rgba(0,0,0,0.6)';
    ctx.beginPath();
    ctx.ellipse(o.x+o.w*0.5, baseY+9, o.w*0.58, 10, 0.12, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    const cx=o.x+o.w*0.5;
    const cy=baseY-o.h*0.50;

    ctx.save();
    const grad=ctx.createLinearGradient(0,baseY-o.h,0,baseY);
    grad.addColorStop(0,'#3d7a3a');
    grad.addColorStop(1,'#163318');
    ctx.fillStyle=grad;

    const s=o.seed;
    const lumpCount=o.lumps;
    for(let i=0;i<lumpCount;i++){
      const a=(i/(lumpCount))*Math.PI*2;
      const rx=o.w*(0.26+(Math.sin(s+i*31)*0.08));
      const ry=o.h*(0.20+(Math.cos(s+i*17)*0.06));
      const ox=Math.cos(a)*o.w*0.18 + Math.sin(s+i*9)*7;
      const oy=Math.sin(a)*o.h*0.12 + Math.cos(s+i*11)*6;
      ctx.beginPath();
      ctx.ellipse(cx+ox, cy+oy, rx, ry, 0, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawCar(o){
    const gy=groundY(o.x);
    const y=gy - o.h;
    const x=o.x;

    ctx.save();
    ctx.globalAlpha=0.20;
    ctx.fillStyle='rgba(0,0,0,0.55)';
    ctx.beginPath();
    ctx.ellipse(x+o.w*0.52, gy+10, o.w*0.42, 8, 0.10, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.fillStyle=o.col;
    roundRect(x, y, o.w, o.h, 10);
    ctx.fill();

    ctx.globalAlpha=0.90;
    ctx.fillStyle='rgba(255,255,255,0.18)';
    roundRect(x+o.w*0.18, y- o.h*0.55, o.w*0.46, o.h*0.65, 10);
    ctx.fill();

    ctx.globalAlpha=0.45;
    ctx.fillStyle='rgba(210,240,255,0.35)';
    roundRect(x+o.w*0.22, y- o.h*0.48, o.w*0.18, o.h*0.40, 6);
    roundRect(x+o.w*0.44, y- o.h*0.48, o.w*0.18, o.h*0.40, 6);
    ctx.fill();

    ctx.globalAlpha=1;
    ctx.fillStyle='#141519';
    ctx.beginPath(); ctx.arc(x+o.w*0.24, gy-4, 8, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+o.w*0.76, gy-4, 8, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  function drawRing(rg){
    ctx.save();
    ctx.globalAlpha = 0.20;
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    ctx.beginPath();
    ctx.ellipse(rg.x+10, rg.y+10, rg.r*1.18, rg.r*0.50, 0.18, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.translate(rg.x, rg.y);
    ctx.rotate(Math.sin(rg.spin)*0.12);
    ctx.save();
    ctx.scale(1.35, 0.90);

    const outerR = rg.r*1.15;
    const innerR = rg.r*0.60;

    const gold = ctx.createLinearGradient(-outerR, -outerR, outerR, outerR);
    gold.addColorStop(0.00,'#fff3c0');
    gold.addColorStop(0.25,'#ffd77a');
    gold.addColorStop(0.55,'#ffb300');
    gold.addColorStop(0.80,'#c98500');
    gold.addColorStop(1.00,'#6f4200');

    ctx.fillStyle = gold;
    ctx.beginPath();
    ctx.arc(0,0,outerR,0,Math.PI*2);
    ctx.arc(0,0,innerR,0,Math.PI*2,true);
    ctx.fill('evenodd');

    ctx.globalAlpha = 0.55;
    ctx.strokeStyle = 'rgba(255,255,255,0.75)';
    ctx.lineWidth = 2.6;
    ctx.beginPath();
    ctx.arc(outerR*0.02, -outerR*0.08, outerR*0.78, -1.20, -0.25);
    ctx.stroke();

    ctx.restore();
    ctx.restore();
  }

  // Albero decorativo (pochi)
  function drawTree(t){
    const gy = groundY(t.x);
    const trunkH = 70 * t.scale;
    const trunkW = 14 * t.scale;

    ctx.save();
    ctx.globalAlpha = 0.16;
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.beginPath();
    ctx.ellipse(t.x + 12*t.scale, gy + 10, 36*t.scale, 8*t.scale, 0.12, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 0.92;
    const wood = ctx.createLinearGradient(0, gy-trunkH, 0, gy);
    wood.addColorStop(0, `rgba(120,85,55,${t.tint})`);
    wood.addColorStop(1, `rgba(70,45,28,${t.tint})`);
    ctx.fillStyle = wood;
    roundRect(t.x - trunkW/2, gy - trunkH, trunkW, trunkH, 6*t.scale);
    ctx.fill();

    const topY = gy - trunkH;
    const g = ctx.createRadialGradient(t.x, topY, 6*t.scale, t.x, topY, 58*t.scale);
    g.addColorStop(0, `rgba(92,180,92,${0.92*t.tint})`);
    g.addColorStop(0.55, `rgba(44,120,60,${0.92*t.tint})`);
    g.addColorStop(1, `rgba(15,45,25,${0.92*t.tint})`);
    ctx.fillStyle = g;

    ctx.beginPath();
    ctx.arc(t.x, topY+10*t.scale, 32*t.scale, 0, Math.PI*2);
    ctx.arc(t.x-22*t.scale, topY+24*t.scale, 26*t.scale, 0, Math.PI*2);
    ctx.arc(t.x+22*t.scale, topY+24*t.scale, 26*t.scale, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  // Formaggio pi√π realistico
  function drawCheese(){
    const gy = groundY(cheese.x);

    // ombra coerente
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = 'rgba(0,0,0,0.65)';
    const sh = 5 + Math.abs(Math.sin(cheese.rot))*2.2;
    ctx.beginPath();
    ctx.ellipse(cheese.x+7, gy+9, cheese.r*1.10, sh, 0.10, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.translate(cheese.x, cheese.y);

    // rotazione + lieve allineamento a pendenza
    ctx.rotate(cheese.rot + groundAngle()*0.22);

    // corpo
    const cg = ctx.createRadialGradient(-7,-7,4, 0,0,cheese.r+12);
    cg.addColorStop(0,'#fff6b8');
    cg.addColorStop(0.55,'#ffd86f');
    cg.addColorStop(1,'#e59a00');
    ctx.fillStyle = cg;
    ctx.beginPath();
    ctx.arc(0,0,cheese.r,0,Math.PI*2);
    ctx.fill();

    // pori
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = 'rgba(130,80,0,0.55)';
    for(let i=0;i<7;i++){
      const a = (i*1.7 + (cheese.rot*0.25)) % (Math.PI*2);
      const rr = cheese.r * (0.15 + (i%3)*0.07);
      const px = Math.cos(a) * (cheese.r*0.45);
      const py = Math.sin(a*0.9) * (cheese.r*0.35);
      ctx.beginPath();
      ctx.ellipse(px, py, rr*0.55, rr*0.38, a*0.3, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    // bordo/crosta
    ctx.save();
    ctx.globalAlpha = 0.42;
    ctx.strokeStyle = '#b97f00';
    ctx.lineWidth = 3.2;
    ctx.beginPath();
    ctx.arc(0,0,cheese.r-1.6,0,Math.PI*2);
    ctx.stroke();
    ctx.restore();

    // highlight
    ctx.save();
    ctx.globalAlpha = 0.55;
    ctx.strokeStyle = 'rgba(255,255,255,0.75)';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.arc(cheese.r*0.08, -cheese.r*0.10, cheese.r*0.78, -1.25, -0.20);
    ctx.stroke();
    ctx.restore();

    ctx.restore();
  }

  /* =========================================================
     RUNNER (testa pi√π grande)
     ========================================================= */
  function solveIK(hip, footPos, l1, l2, bend){
    let dx = footPos.x - hip.x;
    let dy = footPos.y - hip.y;
    let d = Math.hypot(dx,dy);
    d = clamp(d, 0.0001, l1+l2-0.0001);
    const a = Math.atan2(dy,dx);
    const cosH = clamp((l1*l1 + d*d - l2*l2) / (2*l1*d), -1, 1);
    const hipOff = Math.acos(cosH);
    const hipAng = a + bend*hipOff;
    return {knee:{x: hip.x + Math.cos(hipAng)*l1, y: hip.y + Math.sin(hipAng)*l1}};
  }

  function drawFootShape(x,y,ang){
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(ang);
    ctx.fillStyle='#141519';
    roundRect(-4,-3,18,6,3);
    ctx.fill();
    ctx.restore();
  }

  function drawLegIK(hip, footPos, pants, bend, alpha, footAng){
    const l1=30, l2=31;
    const ik = solveIK(hip, footPos, l1, l2, bend);
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = pants;
    ctx.lineWidth = 5;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(hip.x, hip.y);
    ctx.lineTo(ik.knee.x, ik.knee.y);
    ctx.lineTo(footPos.x, footPos.y);
    ctx.stroke();
    ctx.restore();
    drawFootShape(footPos.x, footPos.y, footAng);
  }

  function drawArm(x0,y0,l1,l2,ang,color){
    ctx.save();
    ctx.strokeStyle=color;
    ctx.lineWidth=4;
    ctx.lineCap='round';
    const x1=x0+Math.cos(ang)*l1;
    const y1=y0+Math.sin(ang)*l1;
    const ang2=ang+(Math.sin(ang*1.6)*0.28);
    const x2=x1+Math.cos(ang2)*l2;
    const y2=y1+Math.sin(ang2)*l2;
    ctx.beginPath();
    ctx.moveTo(x0,y0);
    ctx.lineTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.stroke();
    ctx.restore();
  }

  function computeLegT(phase, offset){
    let t = ((phase+offset)/(Math.PI*2)) % 1;
    if(t<0) t += 1;
    return t;
  }

  function legKinematics(phase, offset, stride, lift, bodyH, stanceEnd){
    const t = computeLegT(phase, offset);
    const ground = bodyH - 2;
    let x,y,footAng,inStance;
    if(t < stanceEnd){
      inStance=true;
      const u=smooth(t/stanceEnd);
      x = -stride*0.22;
      y = ground + Math.sin(u*Math.PI)*2.2;
      const toe = clamp((u-0.78)/0.22,0,1);
      y -= toe*3.2;
      footAng = lerp(0.02, 0.42, toe);
    } else {
      inStance=false;
      const u=smooth((t-stanceEnd)/(1-stanceEnd));
      x = lerp(-stride*0.18, stride*0.70, u);
      y = ground - Math.sin(u*Math.PI)*lift;
      footAng = lerp(-0.55, 0.08, u);
    }
    return {t,inStance,x,y,footAng};
  }

  function drawRunner(px, py, crouch, phase, name){
    ctx.save();

    const angSlope = groundAngle();
    const bodyH = crouch ? 66 : 84;

    const stride=28;
    const lift=18;
    const stanceEnd=footLock.stanceEnd;

    const L=legKinematics(phase, Math.PI, stride, lift, bodyH, stanceEnd);
    const R=legKinematics(phase, 0.0,   stride, lift, bodyH, stanceEnd);

    const wrapR = footLock.lastTR > R.t;
    const wrapL = footLock.lastTL > L.t;
    if(wrapR){ footLock.active=true; footLock.leg='R'; footLock.lockScreenX = px + bodyOffsetX + R.x; }
    else if(wrapL){ footLock.active=true; footLock.leg='L'; footLock.lockScreenX = px + bodyOffsetX + L.x; }

    if(footLock.active){
      const still = (footLock.leg==='R') ? R.inStance : L.inStance;
      if(!still) footLock.active=false;
    }

    if(footLock.active){
      const fx = (footLock.leg==='R') ? R.x : L.x;
      const desired = footLock.lockScreenX - (px + fx);
      bodyOffsetX = lerp(bodyOffsetX, desired, 0.22);
    } else {
      bodyOffsetX = lerp(bodyOffsetX, 0, 0.08);
    }

    footLock.lastTR = R.t;
    footLock.lastTL = L.t;

    const hipBob = (Math.sin(phase*2)*2.0 + Math.sin(phase*4+0.6)*0.65);
    const pelvisShift = Math.sin(phase)*2.6;
    const torsoRot = Math.sin(phase+0.4)*0.055;

    ctx.translate(px + bodyOffsetX, py + hipBob);
    ctx.rotate(angSlope*0.36 + torsoRot);

    const shirt = (name==='Anna') ? '#7a5cff' : '#2f7bff';
    const pants = '#2b2f3a';
    const skin  = '#f2c7a5';

    // torso
    ctx.fillStyle = shirt;
    roundRect(-12, 18, 24, crouch?30:34, 8);
    ctx.fill();
    ctx.fillStyle = pants;
    roundRect(-13 + pelvisShift*0.15, 48, 26, 14, 7);
    ctx.fill();

    // neck (leggermente pi√π grande per testa grande)
    ctx.fillStyle = skin;
    roundRect(-5, 12, 10, 10, 5);
    ctx.fill();

    // head with face (PI√ô GRANDE)
    const headR = 16;
    const face = (name==='Anna') ? faceAnna : faceMarco;
    const faceOk = face && !face._bad && face.complete && face.naturalWidth > 0;

    if(faceOk){
      ctx.save();
      ctx.beginPath();
      ctx.arc(0, 0, headR, 0, Math.PI*2);
      ctx.clip();
      ctx.drawImage(face, -headR, -headR, headR*2, headR*2);
      ctx.restore();

      ctx.save();
      ctx.globalAlpha=0.22;
      ctx.strokeStyle='rgba(0,0,0,0.55)';
      ctx.lineWidth=2.2;
      ctx.beginPath();
      ctx.arc(0,0,headR,0,Math.PI*2);
      ctx.stroke();
      ctx.restore();
    } else {
      ctx.fillStyle = skin;
      ctx.beginPath();
      ctx.arc(0,0,headR,0,Math.PI*2);
      ctx.fill();

      ctx.fillStyle = (name==='Anna') ? '#2d1f1b' : '#3a2a1e';
      ctx.beginPath();
      ctx.arc(-2,-2,headR+1, Math.PI*1.05, Math.PI*1.95);
      ctx.fill();
    }

    // arms
    const armSwing = Math.sin(phase + Math.PI)*0.95;
    const shoulderRoll = Math.sin(phase*2)*0.10;
    drawArm( 10, 28, 19, 18,  0.55 + armSwing*0.55 + shoulderRoll, skin);
    drawArm(-10, 30, 19, 18, -0.35 - armSwing*0.55 - shoulderRoll, skin);

    // legs
    const hipL = {x:-7 + pelvisShift*0.45, y:60};
    const hipR = {x: 7 + pelvisShift*0.45, y:60};
    const footLPos = {x: hipL.x + L.x, y: L.y};
    const footRPos = {x: hipR.x + R.x, y: R.y};

    const depthL = L.inStance ? 0.88 : 1.0;
    const depthR = R.inStance ? 0.88 : 1.0;
    const LfootAng = L.inStance ? L.footAng*0.55 : L.footAng;
    const RfootAng = R.inStance ? R.footAng*0.55 : R.footAng;

    if(L.inStance && !R.inStance){
      drawLegIK(hipL, footLPos, pants, -1, 0.85, LfootAng);
      drawLegIK(hipR, footRPos, pants, +1, 1.0, RfootAng);
    } else if(R.inStance && !L.inStance){
      drawLegIK(hipR, footRPos, pants, +1, 0.85, RfootAng);
      drawLegIK(hipL, footLPos, pants, -1, 1.0, LfootAng);
    } else {
      drawLegIK(hipL, footLPos, pants, -1, 0.95*depthL, LfootAng);
      drawLegIK(hipR, footRPos, pants, +1, 0.95*depthR, RfootAng);
    }

    ctx.restore();
  }

  /* =========================================================
     GAME OVER ART (ingessato)
     ========================================================= */
  function castSVG(name){
    const shirt = (name==='Anna') ? '#7a5cff' : '#2f7bff';
    const hair  = (name==='Anna') ? '#2d1f1b' : '#3a2a1e';
    return `
<svg viewBox="0 0 420 260" xmlns="http://www.w3.org/2000/svg" aria-label="Personaggio ingessato">
  <defs>
    <linearGradient id="skin" x1="0" y1="0" x2="1" y2="1">
      <stop offset="0" stop-color="#ffd7bf"/>
      <stop offset="1" stop-color="#e9bfa2"/>
    </linearGradient>
    <linearGradient id="cast" x1="0" y1="0" x2="0" y2="1">
      <stop offset="0" stop-color="#ffffff"/>
      <stop offset="1" stop-color="#dfe6ef"/>
    </linearGradient>
  </defs>
  <rect x="0" y="0" width="420" height="260" rx="22" fill="rgba(0,0,0,0.12)"/>
  <g transform="translate(210 130)">
    <ellipse cx="14" cy="94" rx="120" ry="22" fill="rgba(0,0,0,0.18)"/>
    <rect x="-62" y="-2" width="124" height="94" rx="20" fill="${shirt}" opacity="0.95"/>
    <rect x="-70" y="78" width="140" height="30" rx="16" fill="#2b2f3a" opacity="0.95"/>
    <rect x="-20" y="-38" width="40" height="34" rx="14" fill="url(#skin)"/>
    <circle cx="0" cy="-74" r="36" fill="url(#skin)"/>
    <path d="M-32 -88 C-18 -120, 18 -120, 32 -88 C 18 -98, -18 -98, -32 -88Z" fill="${hair}" opacity="0.95"/>
    <circle cx="-12" cy="-78" r="4" fill="rgba(0,0,0,0.55)"/>
    <circle cx="12" cy="-78" r="4" fill="rgba(0,0,0,0.55)"/>
    <path d="M-10 -62 Q0 -56 10 -62" stroke="rgba(0,0,0,0.45)" stroke-width="4" fill="none" stroke-linecap="round"/>
    <g transform="translate(62,16) rotate(12)">
      <rect x="-6" y="-6" width="18" height="86" rx="10" fill="url(#skin)" opacity="0.9"/>
      <rect x="-14" y="30" width="36" height="68" rx="14" fill="url(#cast)" stroke="rgba(0,0,0,0.12)"/>
      <path d="M-6 40 L14 60 M-6 54 L14 74 M-6 68 L14 88" stroke="rgba(0,0,0,0.10)" stroke-width="4" stroke-linecap="round"/>
    </g>
    <g transform="translate(92,42) rotate(6)" opacity="0.9">
      <rect x="-4" y="-12" width="8" height="136" rx="4" fill="#caa77b"/>
      <rect x="-22" y="-22" width="44" height="12" rx="6" fill="#caa77b"/>
      <rect x="-12" y="96" width="24" height="12" rx="6" fill="#caa77b"/>
    </g>
    <g opacity="0.75">
      <path d="M-120 -120 l10 18 20 6-16 12 2 20-16-12-16 12 2-20-16-12 20-6z" fill="#ffcc00"/>
      <path d="M120 -108 l8 14 16 4-12 10 2 16-14-9-14 9 2-16-12-10 16-4z" fill="#ffd77a"/>
      <path d="M-140 -10 l7 12 14 3-10 8 2 14-12-8-12 8 2-14-10-8 14-3z" fill="#fff3c0"/>
    </g>
  </g>
</svg>`;
  }

  /* =========================================================
     GAME OVER
     ========================================================= */
  function gameOver(){
    state = STATE.OVER;
    hud.style.display='none';
    over.classList.remove('hidden');
    menu.classList.add('hidden');

    const m = Math.floor(distMeters);
    finalNameEl.textContent = playerName;
    finalMetersEl.textContent = m;
    finalRingsEl.textContent = ringsCount;

    castArt.innerHTML = castSVG(character);

    updateBestScore(playerName, m);
    renderLB(lbOver);
  }

  /* =========================================================
     STEP (fisica + spawn + collisioni)
     ========================================================= */
  function step(dt){
    const mode = envMode();
    envChip.textContent = 'Ambiente: ' + (mode===0 ? 'Montagna' : 'Citt√†');

    coyote = Math.max(0, coyote - dt);
    jumpBuf = Math.max(0, jumpBuf - dt);

    const add = Math.floor(distMeters/100) * speedAdd;
    const targetSpeed = 468 + add;
    speed = lerp(speed, targetSpeed, 0.028);

    const metersPerPx = 1/20;
    const dx = speed * dt;
    distMeters += dx * metersPerPx;

    player.runT += dt * (1.2 + speed/520);

    updateCrouchAndFeetLock();

    player.vy += gravity * dt;
    player.y += player.vy * dt;

    const px = player.x();
    const gy = groundY(px);
    const foot = player.y + player.h;

    if(foot >= gy){
      player.y = gy - player.h;
      player.vy = 0;
      if(!player.onGround) coyote = 0.09;
      player.onGround = true;
      coyote = 0.09;
    } else {
      if(player.onGround) coyote = 0.09;
      player.onGround = false;
    }

    if(jumpBuf > 0 && (player.onGround || coyote > 0)){
      doJump();
    }

    // scorrimento mondo
    for(const o of obstacles) o.x -= dx;
    for(const r of rings) { r.x -= dx; r.spin += dt*3.2; }
    for(const s of signs) s.x -= dx;

    // alberi decorativi: parallax (pi√π lenti)
    for(const d of deco) d.x -= dx * d.depth;

    obstacles = obstacles.filter(o => o.x + o.w > -80);
    rings = rings.filter(r => r.x + r.r > -60);
    signs = signs.filter(s => s.x > -260);
    deco = deco.filter(d => d.x > -260);

    if(distMeters >= nextMilestone){
      spawnMilestoneSign(nextMilestone);
      nextMilestone += 500;
    }

    // OSTACOLI PI√ô FREQUENTI (come richiesto)
    if(distMeters >= nextObsAt){
      if(W - lastObstacleX() > MIN_OBS_GAP_PX){
        if(mode===0) spawnBush(); else spawnCar();
      }

      const city = (mode===1);
      const baseGap = city ? 55 : 68;     // pi√π frequenti
      const chaos   = city ? 42 : 50;

      const diff = clamp(distMeters/1600, 0, 1);
      const minGap = lerp(baseGap+18, baseGap, diff);

      nextObsAt = distMeters + (minGap + Math.random()*chaos);

      // in citt√† a volte doppia auto "vicina" (ma non troppo)
      if(city && Math.random() < 0.24){
        if(W - lastObstacleX() > MIN_OBS_GAP_PX + 35){
          spawnCar();
          obstacles[obstacles.length-1].x += 135 + Math.random()*75;
        }
      }
    }

    // ring
    if(distMeters >= nextRingAt){
      const okGap = (W - lastRingX() > MIN_RING_GAP_PX);
      if(okGap){
        const xCandidate = W + 80 + Math.random()*200;
        const nearObs = obstacles.some(o => Math.abs((o.x+o.w*0.5) - xCandidate) < MIN_RING_FROM_OBS_PX);
        if(!nearObs) spawnRing();
      }
      nextRingAt = distMeters + (60 + Math.random()*75);
    }

    // alberi decorativi: pochi (NON pi√π frequenti)
    if(mode===0 && Math.random() < 0.010){
      if(!deco.length || (W - deco[deco.length-1].x) > 220) spawnTree();
    }

    // cheese: attaccato al terreno + rotol√¨o fisico (distanza lungo pendenza / r)
    cheese.x = px + 66;
    cheese.y = groundY(cheese.x) - cheese.r;

    const sAlongGround = dx * groundLenFactor(); // pi√π realistico su pendenza
    cheese.rot += sAlongGround / cheese.r;

    // collisioni
    const pRect = { x: px - player.w/2, y: player.y, w: player.w, h: player.h };

    for(const o of obstacles){
      const ogy = groundY(o.x);
      const oRect = { x: o.x, y: ogy - o.h, w: o.w, h: o.h };

      const tol = 3;
      const a = {x:pRect.x+tol, y:pRect.y+tol, w:pRect.w-2*tol, h:pRect.h-2*tol};
      const b = {x:oRect.x+tol, y:oRect.y+tol, w:oRect.w-2*tol, h:oRect.h-2*tol};

      if(rectsOverlap(a,b)){
        gameOver();
        return;
      }
    }

    for(let i=rings.length-1;i>=0;i--){
      const rg = rings[i];
      if(circleRectOverlap(rg.x, rg.y, rg.r*0.95, pRect.x, pRect.y, pRect.w, pRect.h)){
        rings.splice(i,1);
        ringsCount++;
      }
    }

    metersEl.textContent = Math.floor(distMeters);
    ringsEl.textContent = ringsCount;
    nameChip.textContent = 'Giocatore: ' + playerName;
    charChip.textContent = 'Personaggio: ' + character;
  }

  /* =========================================================
     RENDER
     ========================================================= */
  function render(tms){
    ctx.clearRect(0,0,W,H);

    const mode = envMode();

    drawBackground(mode, tms);
    drawGround(mode);

    if(state===STATE.RUN) drawUpcomingPreview();
    else hintChip.textContent = 'Tap/Spazio salta ¬∑ ‚Üì/Swipe gi√π accovacciati';

    // Alberi decorativi (dietro ostacoli) - pochi
    if(mode===0){
      for(const d of deco) if(d.type==='tree') drawTree(d);
    }

    for(const s of signs) drawSign(s);

    for(const rg of rings) drawRing(rg);

    for(const o of obstacles){
      if(o.type==='bush') drawBush(o);
      else drawCar(o);
    }

    if(state!==STATE.MENU){
      drawCheese();
    }

    if(state===STATE.RUN){
      const px = player.x();
      const py = player.y;
      drawRunner(px, py + 4, player.crouch, player.runT*4.2, character);
    }

    if(state===STATE.MENU){
      const px = W*0.22;
      const gy = groundY(px);
      drawRunner(px, gy-standH+4, false, (tms/1000)*4.1, character);

      cheese.x = px + 66;
      cheese.y = groundY(cheese.x) - cheese.r;
      cheese.rot = (tms/1000)*2.0;
      drawCheese();
    }
  }

  /* =========================================================
     LOOP (timestep fisso)
     ========================================================= */
  let lastT = performance.now();
  let acc = 0;
  const FIXED = 1/120;
  const MAX_DT = 1/20;

  function frame(now){
    const dt = Math.min(MAX_DT, (now - lastT)/1000);
    lastT = now;
    acc += dt;

    while(acc >= FIXED){
      if(state === STATE.RUN) step(FIXED);
      acc -= FIXED;
    }

    render(now);
    requestAnimationFrame(frame);
  }

  /* =========================================================
     STARTUP
     ========================================================= */
  function init(){
    renderLB(lbMenu);
    requestAnimationFrame(frame);
  }
  init();

})();
</script>
</body>
</html>
